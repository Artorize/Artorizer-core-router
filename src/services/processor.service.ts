import { request, FormData } from 'undici';
import { config } from '../config';
import { ProtectRequest, ProcessorResponse, processorResponseSchema } from '../types/schemas';

export class ProcessorService {
  private baseUrl: string;
  private timeout: number;
  private failureCount = 0;
  private circuitOpen = false;
  private lastFailureTime = 0;
  private readonly CIRCUIT_THRESHOLD = 5;
  private readonly CIRCUIT_TIMEOUT = 30000; // 30s

  constructor() {
    this.baseUrl = config.processor.url;
    this.timeout = config.processor.timeout;
  }

  /**
   * Check if circuit breaker is open
   */
  private checkCircuit(): void {
    if (this.circuitOpen) {
      const elapsed = Date.now() - this.lastFailureTime;
      if (elapsed > this.CIRCUIT_TIMEOUT) {
        this.circuitOpen = false;
        this.failureCount = 0;
      } else {
        throw new Error('Processor circuit breaker is open - service temporarily unavailable');
      }
    }
  }

  /**
   * Record failure for circuit breaker
   */
  private recordFailure(): void {
    this.failureCount++;
    this.lastFailureTime = Date.now();

    if (this.failureCount >= this.CIRCUIT_THRESHOLD) {
      this.circuitOpen = true;
    }
  }

  /**
   * Reset circuit breaker on success
   */
  private recordSuccess(): void {
    this.failureCount = 0;
    this.circuitOpen = false;
  }

  /**
   * Submit job to processor with callback (async workflow)
   */
  async submitJobWithCallback(
    jobId: string,
    payload: ProtectRequest,
    fileBuffer: Buffer | undefined,
    filename: string | undefined,
    callbackUrl: string,
    callbackAuthToken: string,
    backendAuthToken: string
  ): Promise<ProcessorResponse> {
    this.checkCircuit();

    try {
      const formData = new FormData();

      // Add file if provided
      if (fileBuffer && filename) {
        formData.append('file', new Blob([fileBuffer]), filename);
      }

      // Create metadata payload matching processor API spec
      const metadata: any = {
        job_id: jobId,
        callback_url: callbackUrl,
        callback_auth_token: callbackAuthToken,
        artist_name: payload.artist_name,
        artwork_title: payload.artwork_title,
        // Backend upload mode (NEW) - processor uploads directly to backend
        backend_url: config.backend.url,
        backend_auth_token: backendAuthToken, // One-time token generated by router
        ...(payload.artwork_description && { artwork_description: payload.artwork_description }),
        ...(payload.artwork_creation_time && { artwork_creation_time: payload.artwork_creation_time }),
        ...(payload.tags && { tags: payload.tags }),
        ...(payload.processors && { processors: payload.processors }),
        ...(payload.watermark_strategy && { watermark_strategy: payload.watermark_strategy }),
        ...(payload.watermark_strength !== undefined && { watermark_strength: payload.watermark_strength }),
        // Legacy fields (still supported by processor for backward compatibility)
        ...(payload.include_hash_analysis !== undefined && { include_hash_analysis: payload.include_hash_analysis }),
        ...(payload.include_protection !== undefined && { include_protection: payload.include_protection }),
        ...(payload.enable_tineye !== undefined && { enable_tineye: payload.enable_tineye }),
        ...(payload.watermark_text && { watermark_text: payload.watermark_text }),
        ...(payload.tree_ring_frequency !== undefined && { tree_ring_frequency: payload.tree_ring_frequency }),
        ...(payload.tree_ring_amplitude !== undefined && { tree_ring_amplitude: payload.tree_ring_amplitude }),
        ...(payload.stegano_message && { stegano_message: payload.stegano_message }),
        ...(payload.image_url && { image_url: payload.image_url }),
        ...(payload.local_path && { local_path: payload.local_path }),
        ...(payload.extra_metadata && { extra_metadata: payload.extra_metadata }),
      };

      formData.append('metadata', JSON.stringify(metadata));

      const response = await request(`${this.baseUrl}/v1/process/artwork`, {
        method: 'POST',
        body: formData as any,
        bodyTimeout: this.timeout,
        headersTimeout: this.timeout,
      });

      if (response.statusCode !== 200 && response.statusCode !== 202) {
        const body = await response.body.text();
        throw new Error(`Processor returned ${response.statusCode}: ${body}`);
      }

      const data = await response.body.json();
      this.recordSuccess();

      return processorResponseSchema.parse(data);
    } catch (error) {
      this.recordFailure();
      throw error;
    }
  }

  /**
   * Get job result from processor (for callback processing)
   */
  async getJobResult(jobId: string): Promise<any> {
    try {
      const response = await request(`${this.baseUrl}/v1/jobs/${jobId}/result`, {
        method: 'GET',
        headersTimeout: this.timeout,
      });

      if (response.statusCode !== 200) {
        const body = await response.body.text();
        throw new Error(`Processor returned ${response.statusCode}: ${body}`);
      }

      return await response.body.json();
    } catch (error) {
      throw new Error(`Failed to get job result: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Download file from processor storage URL
   */
  async downloadFile(url: string): Promise<Buffer> {
    try {
      const response = await request(url, {
        method: 'GET',
        headersTimeout: this.timeout,
        bodyTimeout: this.timeout,
      });

      if (response.statusCode !== 200) {
        throw new Error(`Failed to download from ${url}: ${response.statusCode}`);
      }

      return Buffer.from(await response.body.arrayBuffer());
    } catch (error) {
      throw new Error(`Failed to download file: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Check processor health
   */
  async healthCheck(): Promise<boolean> {
    try {
      const response = await request(`${this.baseUrl}/health`, {
        method: 'GET',
        headersTimeout: 5000,
      });
      return response.statusCode === 200;
    } catch {
      return false;
    }
  }

  /**
   * Get circuit breaker status
   */
  getStatus() {
    return {
      circuitOpen: this.circuitOpen,
      failureCount: this.failureCount,
      lastFailureTime: this.lastFailureTime,
    };
  }
}

// Singleton instance
let instance: ProcessorService | null = null;

export function getProcessorService(): ProcessorService {
  if (!instance) {
    instance = new ProcessorService();
  }
  return instance;
}
